# 链表题
## 普通入门 
- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)
> 1. 注意使用递归和迭代两种解法
> 2. 迭代解法, 怎样优化: *判断如果是第一次迭代, 需要将第一个节点记录下来, 最终返回这个节点?* 这个特殊逻辑?

## 空节点及遍历节点的运用
- [86. 分隔链表](https://leetcode.cn/problems/partition-list/)
> 1. 需要两个变量存大小链表头, 两个指针存两个链表尾, 一个指针遍历当前链表
> 2. 每次遍历原链表, 都需要将当前遍历的节点的 next 断开, 这样才会让大小链表尾指针的 next 是空的

## 有序数组(二叉堆)
- [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

## 滑动窗口
- [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
> 1. 拆解两个部分, 第一步, 实现找到链表的倒数第 n 个结点函数
> > a. 滑动窗口, 让窗口的长度保持为 N, 当窗口走到链表末尾的时候, 窗口起始位置即为倒数第 N 个节点
> 2. 在链表前新增一个虚拟节点, 然后找到虚拟节点为头的链表的倒数第 `N + 1` 个节点, 删除该节点后面的节点, 算法完成
> > a. 这里新增虚拟节点的操作又很秀, 因为如果我们需要删除链表的第一个结点, 此时该节点前在原链表中就没有结点了, 导致算法需要判断特殊逻辑, 复杂度升高, 因此新增一个虚拟节点, 完美解决这个问题

## 快慢指针
- [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list)
> 第一个指针的速度是第二个指针速度的二倍

- [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle)
> 快指针每次走两步, 慢指针每次走一步, 如果存在环, 快指针套慢指针圈的前一步, 快指针一定是比慢指针慢了一步的, 那么下一步两者就会相遇了, 因此如果存在环, 两者必会相遇

- [剑指 Offer II 022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV)
> 1. 先看是否有环
> 2. 如果有环, 需要将快慢指针中的一个, 放到起点, 两者一起走, 相遇的时候, 就是环的起点
> > 两者第一次相遇时, 慢指针走了 `k` 步, 则快指针走了 `2k` 步, 此时可以看到, 则环的大小一定是被 `k` 整除, 画个图就可以了解. 此时将快指针放到起始位置, 假设环的起始位置和两者第一次相遇距离为 `m`, 则, 快指针走到起始环的步数为 `k - m` 步, 而慢指针在环内一直转圈, 当其走了 `k - m` 步的时候, 正好也在环的起始位置, 因为环的大小可以被 `k` 整除

- [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists)
> 1. 解法1(笨)
> > 1. 先遍历两个长度
> > 2. 将长的链表和短链表起始位置对齐
> > 3. 两个指针一起走, 相遇则有交点, 否则没有
> 2. 解法2
> > 1. 将 `a`, `b` 两个链表拼在一起成为 `ab`, 然后和 `ba` 链表比对, 两者如果有交点, 则 `ab` 和 `ba` 最终的节点一定都是相等的
> > 2. 两个指针, `p1` 先遍历 `a`, 再遍历 `b`, `p2` 同步进行 `b` -> `a` 的遍历, 当 `p1` === `p2` 的时候, 循环结束(这里利用了 `null` === `null`) 的特性, 即可以一个 `while(p1 !== p2) {...}` 直接解决战斗  